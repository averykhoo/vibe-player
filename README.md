# Vibe Player

## Overview

This project is a web-based audio player, **Vibe Player**, developed primarily through "vibe coding." Most of the initial code was generated by Large Language Models (LLMs like Google Gemini and OpenAI models) based on high-level prompts reflecting desired functionality or "vibes." The human role was initially limited to copying, pasting, and executing the code.

This current structure and documentation result from a **refactoring process guided and executed by an advanced Gemini model (experienced by the user as `gemini 2.5 pro experimental 03-25`)**, prompted by the observation that the original structure needed improvement for stability and maintainability. The core architectural decisions documented here were made by the LLM assistant to enhance modularity under the specified constraints.

Vibe Player analyzes audio files for Voice Activity Detection (VAD) using the Silero VAD model via ONNX Runtime Web. It displays the audio waveform with detected speech regions highlighted, a spectrogram visualization, and provides standard playback controls.

The entire application uses **vanilla HTML, CSS, and JavaScript**, designed explicitly for **static file hosting** without requiring build tools, frameworks, or package managers.

**Note:** Even this README was largely generated and structured by the Gemini model, based on the project's code and prompts describing its history and structure.

## Features

*   Load local audio files (various formats supported by browser `decodeAudioData`).
*   Standard playback controls: Play/Pause, Seek (via click/drag on visuals), Jump Back/Forward.
*   Adjustable playback speed and volume.
*   **Voice Activity Detection (VAD):**
    *   Uses the pre-trained Silero VAD model via ONNX Runtime Web.
    *   Highlights detected speech regions on the waveform in orange.
    *   Adjustable VAD thresholds (Positive/Negative) for real-time sensitivity tuning (redraws waveform highlighting).
    *   Displays start/end times of detected speech segments.
*   **Visualizations:**
    *   Real-time waveform display.
    *   Spectrogram display (computed using FFT).
    *   Playback progress indicator overlaid on visualizations.
*   Keyboard shortcuts for playback.
*   Responsive canvas visualizations.
*   Pure static deployment - works via simple file serving.

## Technology Stack

*   **HTML5:** Structure and content.
*   **CSS3:** Styling and layout.
*   **JavaScript (ES5/ES6 compatible):** Application logic, DOM manipulation (primarily LLM-generated, refactored by LLM).
*   **Web Audio API:** Audio decoding, playback control, volume adjustment, resampling.
*   **ONNX Runtime Web:** Runs the Silero VAD ONNX model directly in the browser (via WASM).
*   **fft.js:** Simple Fast Fourier Transform library for spectrogram calculation.

## Setup & Running (For Users)

1.  **Get the Files:** Ensure you have the complete project folder (`vibe-player/` or your chosen name), including the `lib/` and `model/` subdirectories with their contents.
2.  **Download ONNX Runtime Web (One-time setup):**
    *   Go to the [ONNX Runtime GitHub Releases](https://github.com/microsoft/onnxruntime/releases).
    *   Find a recent release (e.g., v1.17.0 or later).
    *   Download the **web** package zip file (e.g., `onnxruntime-web-1.17.0.zip`).
    *   Extract the archive. From the `dist/` directory inside, copy the following files into this project's `lib/` folder:
        *   `ort.min.js`
        *   `ort-wasm.wasm`
        *   `ort-wasm-simd.wasm` (Recommended for better performance)
        *   `ort-wasm-threaded.wasm` (Optional, not currently used but good to have)
    *   *(You only need to do this once unless you update ONNX Runtime later).*
3.  **Serve Statically:** You need a simple local HTTP server because browsers restrict some features when opening HTML files directly (`file://`).
    *   **Option A: Using Python (Recommended for local use):**
        *   Open your terminal or command prompt.
        *   Navigate (`cd`) into the main project directory (`vibe-player/`).
        *   Run the command: `python -m http.server 8000` (Use `python3` if `python` maps to Python 2). You can use a different port number if 8000 is busy.
    *   **Option B: Using other static servers or VS Code Live Server:** Any tool that serves the folder contents over HTTP will work.
4.  **Access:** Open your web browser (like Chrome, Firefox, Edge) and go to `http://localhost:8000` (or the address/port your server is using).
5.  **Use:** Click the file input ("Load Audio File") to load an audio file. Use the controls to play, pause, seek, adjust speed/volume, and tune VAD sensitivity using the sliders.

## Deploying to GitHub Pages (Optional)

You can host Vibe Player for free using GitHub Pages:

1.  Create a **public** GitHub repository (e.g., `vibe-player`).
2.  Ensure your local project folder has the following structure (all site files directly in the root):
    ```
    vibe-player/
    ├── index.html
    ├── styles.css
    ├── js/
    ├── lib/
    ├── model/
    └── README.md
    ```
3.  Initialize Git, add all files, commit, add the GitHub repository as the remote origin, and push:
    ```bash
    cd vibe-player
    git init -b main
    git add .
    git commit -m "Initial commit"
    git remote add origin https://github.com/<username>/vibe-player.git
    git push -u origin main
    ```
    *(Replace `<username>` with your GitHub username)*
4.  In your repository settings on GitHub, go to the "Pages" section.
5.  Under "Build and deployment", select "Deploy from a branch".
6.  Choose the `main` branch and the `/ (root)` folder as the source. Click "Save".
7.  Wait a few minutes for deployment. Your site will be live at `https://<username>.github.io/vibe-player/`.

## Project Structure (File Layout)

```
vibe-player/
├── index.html # Main HTML file, includes structure and script loading order.
├── styles.css # All CSS styling.
├── model/
│ └── silero_vad.onnx # The pre-trained Silero VAD model file.
├── lib/ # External, third-party libraries.
│ ├── ort.min.js # ONNX Runtime core JS library.
│ ├── ort-wasm.wasm # ONNX Runtime core WASM binary.
│ ├── ort-wasm-simd.wasm # ONNX Runtime SIMD WASM binary.
│ ├── ort-wasm-threaded.wasm # ONNX Runtime Threaded WASM binary.
│ └── fft.js # FFT library (provides global 'FFT' constructor).
├── js/ # Application-specific JavaScript modules.
│ ├── app.js # Main app orchestrator & namespace root.
│ ├── uiManager.js # Handles DOM interactions & UI events.
│ ├── audioEngine.js # Manages Web Audio API, <audio> element, playback.
│ ├── sileroWrapper.js # Wraps ONNX Runtime session for Silero.
│ ├── sileroProcessor.js # Core VAD processing logic using the wrapper.
│ ├── vadAnalyzer.js # Manages VAD results, thresholds, and recalculations.
│ └── visualizer.js # Handles all canvas drawing (Waveform, Spectrogram).
└── README.md # This file.
```


---
---

## Developer Notes (For LLM Assistants)

**(LLM Assistant: These notes describe the architecture resulting from the Gemini-led refactoring process (initiated Nov 2023 - May 2024). The goal was to improve modularity and maintainability for future LLM-driven development under strict static-hosting constraints. Adhere to these patterns unless explicitly instructed otherwise.)**

**Core Constraints & Design Philosophy:**

1.  **Static Files Only:** Must run when served as simple static files. Compatible with GitHub Pages, Minio, etc. No server-side logic.
2.  **No Build Tools:** No `npm`, `webpack`, `vite`, `parcel`, `babel`, etc. Code runs directly in modern browsers.
3.  **No Frameworks:** Vanilla JavaScript, HTML, CSS only.
4.  **Vibe Coding Origin / LLM Maintenance:** Initial code generated by LLMs. This structure facilitates future LLM interaction. Clarity, modularity, and adherence to established patterns are prioritized.

**Architectural Pattern: IIFE + Global Namespace (`AudioApp`)**

*   **Problem:** Need modularity without ES Modules (due to static file/no build tool constraint).
*   **Solution (Implemented by Gemini):**
    *   A single global object `AudioApp` is created by `js/app.js`.
    *   Each `.js` file in the `js/` directory defines a "module" wrapped in an Immediately Invoked Function Expression (IIFE).
    *   The IIFE returns an object containing the public methods/properties.
    *   This public interface is attached to the `AudioApp` namespace (e.g., `AudioApp.uiManager = ...`).
    *   Code *inside* the IIFE but *not* returned is private.
*   **Benefit:** Organizes code by responsibility, reduces global scope pollution (only `AudioApp`, `ort`, `FFT` global), works statically.
*   **LLM Task:** Place new/modified logic in the appropriate module file. Wrap code in the existing IIFE. Expose necessary functions via the `return` object.

**Communication Pattern: Custom DOM Events**

*   **Problem:** Need communication between modules without tight coupling.
*   **Solution (Implemented by Gemini):**
    *   Modules dispatch `CustomEvent` on the global `document` (e.g., `audioapp:playPauseClicked`, `audioapp:timeUpdated`). Names prefixed `audioapp:`. Data in `event.detail`.
    *   `js/app.js` listens for these events and coordinates actions by calling methods on other modules via `AudioApp.targetModule.doSomething()`.
*   **Benefit:** Decouples modules. Simplifies dependency reasoning.
*   **LLM Task:** For new interactions:
    1.  Identify originating module.
    2.  Dispatch `CustomEvent` with descriptive name and `detail` payload.
    3.  Add listener in `js/app.js`.
    4.  Call target module method(s) in the listener.

**Module Responsibilities (Summary):**

*   `app.js`: Orchestrator, event hub, main `init`. Holds minimal state (buffers, VAD results).
*   `uiManager.js`: DOM elements, UI event listeners -> dispatches events, UI update methods (like `setFileInfo`, `setSpeechRegionsText`).
*   `audioEngine.js`: Web Audio, `<audio>`, load/decode/resample -> dispatches events, playback methods. Manages `ObjectURL`. Closes `AudioContext`.
*   `sileroWrapper.js`: ONNX session management (idempotent `create`), state (`h`, `c`), WASM path config. Provides `process` for inference. **Crucial for VAD.**
*   `sileroProcessor.js`: Frame-by-frame VAD logic using the wrapper, region calculation/recalculation function (`recalculateSpeechRegions`). Calls `wrapper.reset_state`.
*   `vadAnalyzer.js`: Stores VAD results (probabilities, regions, params), handles threshold state from UI events, triggers recalculations via processor.
*   `visualizer.js`: Canvas drawing (waveform, spectrogram), FFT usage, spectrogram caching, progress bars, resize handling, canvas clicks -> dispatches events.

**Critical Dependencies & Configuration:**

*   **`lib/` Folder:** Contains `ort.min.js`, `.wasm` files, `fft.js`. **Must be present.**
*   **`index.html` Script Load Order:** `<script>` tags **MUST** load `ort.min.js`, `fft.js`, then `app.js`, then other `js/*.js` files, finally the inline init call.
*   **`sileroWrapper.js` (`wasmPaths`):** Configures ONNX Runtime to find `.wasm` files in `lib/`. **Verify path if `lib/` location changes.**
*   **`model/silero_vad.onnx`:** Model path is relative (`./model/silero_vad.onnx`) in `sileroWrapper.js`.

**Recent Fixes (May 2024):**

1.  Ensured `AudioApp.sileroWrapper.create()` is called (and awaited) in `app.js` *before* VAD analysis is attempted, resolving "session not initialized" errors. Made `create` idempotent.
2.  Corrected a typo in `app.js` calling `uiManager.setSpeechRegionsText` (was incorrectly `updateSpeechRegionsText`).
3.  Ensured `uiManager.js` correctly exports `setSpeechRegionsText` in its return object.

**Potential Future Work (Areas for LLM focus):**

*   **Error Handling:** More robust user feedback in the UI for all error types (decoding, VAD load/run, WASM load).
*   **Web Workers:** Move heavy tasks (decode, resample, VAD analyze, spec compute) to improve UI responsiveness for large files. Requires careful implementation of worker communication.
*   **Spectrogram Performance:** Further optimize drawing if needed (e.g., WebGL).
*   **State Management:** If complexity increases, centralize state updates within `app.js` more formally, but maintain simplicity.
*   **UI Enhancements:** Zoom/pan, region selection/editing, more metadata display. Handle new UI elements in `uiManager` and events in `app.js`.

**(LLM Assistant: Remember these architectural patterns, dependencies, and recent fixes when generating or modifying code for Vibe Player.)**