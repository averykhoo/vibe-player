# REFACTOR_PLAN.txt
Of course. This is the right approach—solidifying the plan with all the new information and recommendations before starting implementation.

Here is the complete, rewritten V3 plan. It incorporates the decision to use a modern UI, the NPM package for ONNX, and all the architectural and risk-mitigation strategies we've discussed. This document is designed to be a definitive blueprint for the project.

---

## **Vibe Player V2: The SvelteKit Refactoring Plan (Version 3.0 - Final)**

### **1. Vision & Executive Summary**

This document outlines the complete plan to refactor Vibe Player from its original IIFE-based architecture to a modern, robust, and maintainable application built on SvelteKit and TypeScript.

The primary goals are to eliminate the architectural problems of the original version—specifically the reliance on global variables, script load order, and manual DOM manipulation—and to create a superior developer and user experience. A key design decision for V2 is to create a **clean, modern, and accessible user interface**, moving away from the original retro aesthetic to improve usability and maintainability.

The final "V2" application will be:

*   **Declarative & Reactive:** The UI will be a direct function of the application's state, updating automatically.
*   **Type-Safe:** Leveraging TypeScript to prevent common bugs and improve code clarity.
*   **Modular & Decoupled:** A clean separation between UI components, state stores, business logic services, and intensive background workers.
*   **Performant:** Built with Svelte's compile-time optimizations and Vite's fast tooling.
*   **Statically Deployable:** The final output will be a folder of static files, fully compatible with GitHub Pages or any simple web server, preserving the original's deployment simplicity.
*   **Feature-Complete:** All core features of the original, including URL state serialization for sharing links with specific settings, will be preserved and enhanced.

### **2. The Final Technology Stack**

| Category                  | Tool / Technology                                       | Role & Rationale                                                                                                                                                            |
| :------------------------ | :------------------------------------------------------ | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Framework**             | **SvelteKit**                                           | Provides the application structure, file-based routing, and a powerful build system powered by Vite. Its `adapter-static` is perfect for our deployment needs.            |
| **UI Library**            | **Svelte**                                              | A compiler that turns components into highly efficient vanilla JavaScript. Its reactivity model is ideal for this project.                                              |
| **Language**              | **TypeScript**                                          | Enforces type safety across the entire codebase, eliminating a major class of runtime errors and making the code self-documenting.                                     |
| **Styling**               | **Tailwind CSS**                                        | A utility-first CSS framework for rapidly building a custom, modern design without writing extensive custom CSS. Ensures a tiny, optimized final CSS file.               |
| **Component Library**     | **Skeleton UI**                                         | A Svelte-native component library built on Tailwind CSS. It provides pre-built, accessible components (Buttons, Sliders, etc.) to accelerate modern UI development.       |
| **State Management**      | **Svelte Stores**                                       | The simple, powerful, and built-in solution for reactive state management. We will use multiple stores for clear separation of concerns, including `derived` stores.       |
| **WASM/ML Libraries**     | **`onnxruntime-web` (NPM)** & `rubberband-wasm` (static) | `onnxruntime-web` will be managed via NPM for robust VAD analysis. `rubberband` assets will be served statically from the `static` folder.                              |
| **Testing**               | **Vitest & Playwright**                                 | A complete testing suite. Vitest for fast unit/component tests, and Playwright for robust end-to-end browser tests.                                                  |
| **Code Quality**          | **ESLint & Prettier**                                   | Essential tools for automatically enforcing consistent code style and catching potential bugs before they happen.                                                        |
| **Build Tooling**         | **Vite**                                                | SvelteKit's underlying build tool. We will leverage its first-class support for Web Workers (`?worker`) and static asset handling.                                    |

### **3. The Final Architecture**

The V2 architecture uses a **unidirectional data flow** for a clear and predictable application state.

**Core Data Flow:**
`User Action in Component` -> `Calls Service Method` -> `Service Performs Logic` -> `Service Updates Store` -> `Component Reactively Updates`

#### **3.1. Directory Structure**

```
.
├── .github/
├── build/                  <-- Final static output folder
├── static/                 <-- Non-NPM assets (rubberband.wasm, silero_vad.onnx)
├── src/
│   ├── lib/
│   │   ├── actions/
│   │   │   └── sparkles.action.ts
│   │   ├── components/
│   │   │   ├── visualizers/
│   │   │   │   ├── Waveform.svelte
│   │   │   │   └── Spectrogram.svelte
│   │   │   ├── Controls.svelte
│   │   │   └── FileLoader.svelte
│   │   ├── services/
│   │   │   ├── audioEngine.service.ts
│   │   │   └── analysis.service.ts
│   │   ├── stores/
│   │   │   ├── player.store.ts
│   │   │   ├── status.store.ts
│   │   │   ├── analysis.store.ts
│   │   │   └── derived.store.ts      <-- For computed state like isAppBusy
│   │   ├── types/
│   │   │   ├── index.ts
│   │   │   └── worker.types.ts       <-- For type-safe worker messages
│   │   ├── utils/
│   │   │   └── index.ts
│   │   └── workers/
│   │       ├── rubberband.worker.ts
│   │       ├── sileroVad.worker.ts
│   │       └── spectrogram.worker.ts
│   ├── routes/
│   │   └── +page.svelte
│   └── app.html
├── tests/
└── svelte.config.js
```

#### **3.2. Architectural Layers**

1.  **Service Layer (`src/lib/services/`):**
    *   The "brain" of the application. Services are UI-agnostic TypeScript **singletons** (created once and exported) that handle complex logic.
    *   Each service will expose `initialize()` and `dispose()` methods to be called from the main component's lifecycle hooks (`onMount`, `onDestroy`).
    *   `audioEngine.service.ts`: Manages the Web Audio API and the Rubberband WASM worker.
    *   `analysis.service.ts`: Manages the Silero VAD worker and contains the rewritten Goertzel logic for tone detection.

2.  **State Layer (`src/lib/stores/`):**
    *   The reactive "heart" and single source of truth, composed of multiple Svelte stores.
    *   `derived.store.ts` will be used to compute values from other stores (e.g., an `isAppBusy` flag) to simplify logic in components.

3.  **Component Layer (`src/lib/components/` & `src/routes/`):**
    *   The "face" of the application. Components are "dumb" and focused on presentation.
    *   They **read** from stores to display data and **call** service methods to trigger actions.
    *   Visualizers (`Waveform.svelte`, `Spectrogram.svelte`) are now self-contained Svelte components.

4.  **Worker Layer (`src/lib/workers/`):**
    *   A dedicated home for all Web Worker scripts, used for computationally intensive tasks.
    *   Vite's `?worker` import syntax will be used to handle bundling and pathing automatically.

5.  **Actions Layer (`src/lib/actions/`):**
    *   Home for Svelte Actions, which are functions that provide a clean way to interact directly with DOM elements.
    *   `sparkles.action.ts` will encapsulate the sparkle effect.

### **4. Step-by-Step Migration Process**

This will be performed on a dedicated `feature/svelte-refactor` branch.

1.  **Phase 0: Project Scaffolding & Configuration:**
    *   Run `npm create svelte@latest vibe-player-v2`. Select "Skeleton project" with TypeScript, ESLint, Prettier, Playwright, Vitest.
    *   `cd vibe-player-v2` and `npm install`.
    *   Install dependencies: `npm install onnxruntime-web` and `npm install -D tailwindcss postcss autoprefixer vite-plugin-static-copy`.
    *   Initialize Tailwind: `npx svelte-add@latest tailwindcss`.
    *   Configure `adapter-static` in `svelte.config.js`.
    *   In `vite.config.js`, configure `vite-plugin-static-copy` to copy the `onnxruntime-web` WASM files to the build output directory.

2.  **Phase 1: Asset & Core Logic Migration:**
    *   Copy `rubberband.wasm`, `rubberband-loader.js`, and `silero_vad.onnx` into `vibe-player-v2/static/`.
    *   Create the Svelte stores in `src/lib/stores/`, including `derived.store.ts`.
    *   Rewrite `constants.js` and `utils.js` as typed TypeScript modules in `src/lib/utils/index.ts`.
    *   Implement URL State Serialization: Create a utility that subscribes to stores and updates the URL via `goto()`. This utility must use **debouncing** to avoid excessive updates and a flag to prevent loops during initial page load.

3.  **Phase 2: Service & Worker Implementation:**
    *   Create a shared `src/lib/types/worker.types.ts` file to define interfaces for all `postMessage` data, ensuring type-safe communication.
    *   Implement the singleton `audioEngine.service.ts` and its `rubberband.worker.ts`.
    *   Implement the singleton `analysis.service.ts` and its `sileroVad.worker.ts`. This service will import `onnxruntime-web` as a module.

4.  **Phase 3: UI Reconstruction:**
    *   Clear `src/routes/+page.svelte` and build the main layout using Skeleton UI components for a modern, clean aesthetic. This is a full UI redesign.
    *   In `+page.svelte`, use `onMount` and `onDestroy` to call the `initialize()` and `dispose()` methods of the services.
    *   Create reusable Svelte components (`FileLoader.svelte`, `Controls.svelte`, etc.) and the visualizer components.
    *   Implement `sparkles.action.ts` and apply it to a root layout element.

5.  **Phase 4: Test Rewrite:**
    *   Write Vitest unit tests for utility functions and services. **Plan for extensive mocking** of browser-only APIs (`AudioContext`, `Worker`, `ort.InferenceSession`) using Vitest's `vi.mock()` capabilities.
    *   Write Vitest + Svelte Testing Library component tests for key UI interactions.
    *   Rewrite the Playwright E2E tests to target the new component structure and user flows.

6.  **Phase 5: Documentation & The Switchover:**
    *   Rewrite `architecture.md` to fully document the new SvelteKit architecture. Update `README.md`.
    *   Once the feature branch is complete, merge it into `main`.
    *   Update all `.github/workflows/*.yml` files. The `path` for `upload-pages-artifact` in `deploy.yml` will now be `./build`, and test/build commands will be `npm run test` and `npm run build`.
    *   In a separate PR, delete the old `vibe-player` directory and all obsolete root-level files to finalize the transition.

### **5. Key Challenges & Solutions**

*   **Challenge: `AudioContext` User Gesture Policy.** Modern browsers block audio until a user interaction.
    *   **Solution:** The `audioEngine.service` will have an `unlockAudio()` method. This method will be called only once, after the first user click (e.g., on the "Choose File" button), ensuring the `AudioContext` is properly resumed.

*   **Challenge: Dual WASM Loading Patterns.** `onnxruntime-web` fetches its own WASM, while Rubberband uses a legacy loader.
    *   **Solution:** The `audioEngine.service` will pass the public path to `rubberband.wasm` (constructed using SvelteKit's `$app/paths`) as an initialization message to its worker. This ensures the worker knows where to find its static asset.

*   **Challenge: Worker Type-Safety.** `postMessage` is inherently untyped.
    *   **Solution:** We will create and use a shared `src/lib/types/worker.types.ts` file that defines interfaces for all worker message payloads. Both the services and the workers will import these types.

*   **Challenge: Testing Browser-Dependent Services.** Vitest runs in Node.js and lacks browser APIs.
    *   **Solution:** The test plan explicitly includes a phase for creating robust mocks for `AudioContext`, `Worker`, and other browser-only globals, allowing for isolated unit testing of service logic.

### **6. Architectural Principles (The V2 Golden Rules)**

*   **Prefer Svelte Reactivity over Direct DOM Manipulation.** All UI updates should be a result of store changes.
*   **Keep Components Focused on Presentation.** Complex logic, state management, and side effects belong in services and stores.
*   **Maintain Unidirectional Data Flow.** Services update stores; components read from stores and call services. Services do not read from stores to prevent circular dependencies.
*   **Encapsulate Intensive Tasks in Workers.** Any long-running or CPU-intensive task (VAD, spectrograms, audio processing) must be offloaded to a Web Worker to keep the UI responsive.